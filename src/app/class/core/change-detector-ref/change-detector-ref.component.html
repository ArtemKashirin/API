<p><a [href] = "this.ChangeDetectorRef">ChangeDetectorRef</a> - базовый абстрактный класс от которого наследуется класс ViewRef,
  обеспечивающий обнаружение изменений. Формируется дерево обнаружение изменений, в которое собираются все представления, которые необходимо
  проверить на наличие изменений. Наглядно возможно постреть в консоли, что ChangeDetectorRef класс не создается, создается класс ViewRef
  который представляет текущий компонент.</p>

<!--<ul>-->
<!--  <li><i>markForCheck(): void</i> - метод, когда компонент использует стратегию обнаружение изменение OnPush, представление помечается как-->
<!--    измененное, чтоб его можно было снова проверить. Компоненты обычно помечаются как грязные (нуждающиеся в повторной визуализации),-->
<!--    когда входные данные были изменены или в представлении возникли события. Вызовите этот метод, чтобы убедиться, что компонент-->
<!--    проверен, даже если эти триггеры не сработали.</li>-->
<!--  <li><i>detach(): void</i> - метод, отсоединяет представление от дерева обнаружения изменение и отсоединенное представление не-->
<!--проверяется, пока вновь не будет присоединено. </li>-->
<!--  <li><i>detectChanges(): void</i> - метод, проверяет представление и его дочерние представления на изменения.</li>-->
<!--  <li><i>checkNoChanges(): void</i> - метод, проверяет детектор изменений представления и его дочерние представления и пробрасывает ошибку в-->
<!--    консоль если обнаруживаются какие-либо изменения.</li>-->
<!--  <li><i>reattach(): void</i> - метод, присоединяет ранее отключенные представления к дереву обнаружения изменений.</li>-->

<!--  <p>{{ this.inc }}</p>-->
<!--  <button (click)="this.markForCheck()">markForCheck()</button>-->
<!--  <button (click)="this.detach()">detach()</button>-->
<!--  <button (click)="this.detectChanges()">detectChanges()</button>-->
<!--  <button (click)="this.checkNoChanges()">checkNoChanges()</button>-->
<!--  <button (click)="this.reattach()">reattach()</button>-->
<!--</ul>-->
